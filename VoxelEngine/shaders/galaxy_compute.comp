#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Star {
    vec3 position;
    vec3 velocity;
};

layout(push_constant) uniform Push {
    float deltaTime;
    float totalTime;
    int numStars;
} push;

layout(std430, binding = 0) readonly buffer StarBufferIn {
    Star starsIn[];
};

layout(std430, binding = 1) buffer StarBufferOut {
    Star starsOut[];
};

void main() {
    uint index = gl_GlobalInvocationID.x;

    if (index >= push.numStars) {
        return;
    }

    Star starIn = starsIn[index];
    Star starOut;

    // Calculate base rotation speed (one full rotation per 5 seconds)
    const float ROTATION_SPEED = 0.9; // 2π/5 ≈ 1.26, but we'll use a slower speed

    // Instead of using deltaTime directly for the angle, use it to progress through the circle
    float angle = push.totalTime * ROTATION_SPEED;

    // Get current radius (distance from center)
    float radius = length(starIn.position.xz);

    // Calculate new position directly using sine and cosine
    starOut.position = vec3(
            radius * cos(angle),
            starIn.position.y,
            radius * sin(angle)
        );

    // Calculate velocity as the tangent to the circle
    starOut.velocity = vec3(
            -radius * sin(angle) * ROTATION_SPEED,
            0.0,
            radius * cos(angle) * ROTATION_SPEED
        );

    starsOut[index] = starOut;
}
